package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var genTmpl string = `// generated by res2go DO NOT EDIT
package {{.Package}}

var {{.Prefix}}Files map[string][]byte
{{$prefix := .Prefix}}
func {{.Prefix}}Init(){
	{{.Prefix}}Files = make(map[string][]byte)
	{{- range $name, $file := .Resources }}
	{{$prefix}}Files["{{ $name }}"] = []byte{ {{ format $file }} }
	{{- end }}
}
`

type genCtx struct {
	Package   string
	Resources map[string][]byte
	Prefix    string
}

func (g *genCtx) generate() ([]byte, error) {
	fileTemplate := template.Must(template.New("").Funcs(map[string]interface{}{"format": FormatBuffer}).Parse(genTmpl))
	stream := &bytes.Buffer{}
	err := fileTemplate.Execute(stream, g)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error executing template", err)
		return nil, err
	}

	return format.Source(stream.Bytes())
}

func FormatBuffer(sl []byte) string {
	builder := strings.Builder{}
	for i, v := range sl {
		if i%40 == 0 {
			builder.WriteString("\n")
		}
		builder.WriteString(fmt.Sprintf("0x%02x,", int(v)))
	}
	return builder.String()
}

func loadFile(file string, resdata map[string][]byte) error {
	b, err := ioutil.ReadFile(file)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading %s: %s", file, err)
		return err
	}
	key := strings.ReplaceAll(file, "\\", "/")
	resdata[key] = b
	fmt.Println(key, " added")
	return nil
}

func loadDirectory(directory string, resdata map[string][]byte) error {
	return filepath.Walk(directory,
		func(path string, info os.FileInfo, err error) error {
			fmt.Println("scanning ", path, " ", directory)
			if err != nil {
				fmt.Fprintln(os.Stderr, "Error :", err)
				return err
			}
			// relativePath := filepath.ToSlash(strings.TrimPrefix(path, directory))
			if info.IsDir() {
				return nil
			}
			err = loadFile(path, resdata)
			return err
		})
}

func main() {
	packageName := flag.String("package", "resources", "package name")
	outputfile := flag.String("o", *packageName+".go", "output file")
	prefix := flag.String("prefix", "", "add prefix to all exported function")
	flag.Parse()
	resources := flag.Args()

	if resources == nil {
		fmt.Fprintln(os.Stderr, "no directory nor files provided")
		os.Exit(1)
	}

	ctx := genCtx{*packageName, make(map[string][]byte), *prefix}
	for _, file := range resources {
		fmt.Printf("Analyzing %s\n", file)
		matches, _ := filepath.Glob(file)
		for _, match := range matches {
			fmt.Println(match)
			info, err := os.Stat(match)
			if os.IsNotExist(err) {
				fmt.Fprintf(os.Stderr, "Resources %s does not exists\n", match)
				break
			}
			if info.IsDir() {
				err = loadDirectory(match, ctx.Resources)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error parsing directory %s : %v\n", info.Name(), err)
					os.Exit(1)
				}
			} else {
				err = loadFile(match, ctx.Resources)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error loading file %s : %v\n", info.Name(), err)
					os.Exit(1)
				}
			}
		}
	}

	// generate output TODO : Make directory package
	data, err := ctx.generate()
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error formatting generated code", err)
		os.Exit(1)
	}

	err = os.MkdirAll(filepath.Dir(*outputfile), os.ModePerm)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error creating directory path", err)
		os.Exit(1)
	}

	err = ioutil.WriteFile(*outputfile, data, 0644)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error writing blob file", err)
	}
}
