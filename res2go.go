package main

import (
	"flag"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var genTmpl string = `// generated by res2go DO NOT EDIT
package {{.Package}}

var Files map[string][]byte

func Init(){
	Files = make(map[string][]byte) 
	{{- range $name, $file := .Resources }}
    	Files["{{ $name }}"] = []byte{ {{ format $file }} }
	{{- end }}
}
`

type genCtx struct {
	Package string
	Resources map[string][]byte
}

func (g *genCtx) generate() ([]byte, error) {
	fileTemplate := template.Must(template.New("").Funcs(map[string]interface{}{"format": FormatBuffer}).Parse(genTmpl))
	stream := &bytes.Buffer{}
	err := fileTemplate.Execute(stream,g)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error executing template", err)
		return nil, err
	}

	return format.Source(stream.Bytes())
}

func FormatBuffer(sl []byte) string {
	builder := strings.Builder{}
	for i, v := range sl {
		if i % 40 == 0 {
			builder.WriteString("\n")
		}
		builder.WriteString(fmt.Sprintf("0x%02x,", int(v)))
	}
	return builder.String()
}

func loadFile(file string, resdata map[string][]byte) error {
	b, err := ioutil.ReadFile(file)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading %s: %s", file, err)
		return err
	}
	resdata[file] = b
	fmt.Println(file, " added")
	return nil
}

func loadDirectory(directory string, resdata map[string][]byte) error {
	return filepath.Walk(directory, 
		func(path string, info os.FileInfo, err error) error {
			fmt.Println("scanning ", path, " ", directory)
			if err != nil {
				fmt.Fprintln(os.Stderr, "Error :", err)
				return err
			}
			//relativePath := filepath.ToSlash(strings.TrimPrefix(path, directory))
			if info.IsDir() {
				return nil
			} 
			loadFile(path, resdata)
		return nil
	})
}

func main() {
	packageName := flag.String("package", "resources", "package name")
	outputfile := flag.String("o", *packageName + ".go", "output file")
	flag.Parse()
	resources := flag.Args() 
	
	if resources == nil {
		fmt.Fprintln(os.Stderr, "no directory nor files provided")
		os.Exit(1)
	}

	ctx := genCtx{*packageName, make(map[string][]byte)}
	for _, file := range resources {
		fmt.Printf("Analyzing %s\n", file)
		info, err := os.Stat(file)
		if os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr,"Resources %s does not exists\n", file)
		}
		if info.IsDir() {
			loadDirectory(file, ctx.Resources)
			// todo manage error
		} else {
			loadFile(file, ctx.Resources)
			// todo manage error
		}
	}	

	// generate output TODO : Make directory package
	data, err := ctx.generate()
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error formatting generated code", err)
		os.Exit(1)
	}

	err = ioutil.WriteFile(*outputfile, data, 0644)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error writing blob file", err)
	}
}